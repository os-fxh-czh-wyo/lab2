# 实验二：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？
**解答：**

- `default_init()`函数是内存管理器的初始化入口，在系统启动时调用一次，起到了创建空的双向循环链表用于管理空闲内存块、清空空闲页计数器的作用。
  
- `default_init_memmap`函数主要的作用是维护地址有序性为后续合并操作奠定基础，其实现的功能主要有：
  
  - 初始化每个物理页，实现对一段连续的物理内存区域的初始化
    
  - 设置每个物理页的初始数据，清除标志位和属性，并使引用计数归零
    
  - 设置空闲块首页的属性，用`property`字段记录块的大小
    
  - 按物理地址升序插入空闲链表
    
- `default_alloc_pages`函数起到了保持链表有序性的作用，最小化分配操作对链表结构的破坏。其处理逻辑有：
  
  - 进行首次适应搜索，从链表头开始线性搜索，找到第一个满足大小的空闲块
    
  - 对块进行分割处理：将空闲块大于需求的部分进行分割，分割出的部分作为新块插入原来的位置
    
  - 更新内存页管理状态，减少空闲页计数，然后清除分配块的首页标记
    
- `default_free_pages`函数执行了合并操作，这是减少内存碎片的关键做法。其处理顺序为：
  
  - 释放已经分配的物理页
    
  - 重置页的初始数据，清除标志位并使引用计数归零
    
  - 创建新空闲块，设置其首页属性后标记为空闲块
    
  - 按照地址有序插入空闲链表
    
  - 执行双向合并，分别检查其与前一个块、后一个块的连续性，合并相邻的空闲块
    
- `default_nr_free_pages`函数的作用是返回当前页的总数。
  
- `basic_check`和`default_check`是测试函数，确保内存管理器正确运行。
  
  - `basic_check`负责基础功能测试，测试单页的分配和释放，并负责基本链表的操作验证
    
  - `default_check`负责高级功能测试，测试多页的分配和释放、块的分割与合并的验证、碎片处理的测试
    
- `default_pmm_manager`是一个结构体，负责封装内存管理器接口，提供统一的访问点，并且支持多算法扩展。面向接口的设计使它便于替换不同的算法。
  
- 改进思路主要有：
  
  - 外部碎片积累可能会影响大块分配，可以定期进行碎片整理
    
  - 只使用首次适应可能对性能产生影响，可以对小请求使用首次适应，大请求使用最佳适应
    
  - 对于频繁请求分配的区域可以预留内存，保证其实时性
    
  - 目前的合并只检查相邻块，可以尝试跨块进行合并

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
